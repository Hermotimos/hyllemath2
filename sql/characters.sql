
/*
NOTES:
    Table field types:
    - always CHAR(n) and VARCHAR(n) for textual data, never TEXT: it's slower but much more tidy and portable;
      1) otherwise with unmanaged models the control would have to be done in Django forms etc.
      2) in SQL each TEXT field would need a comment about the length to be checked in Python or JS


    - use INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY instead of SERIAL PRIMARY KEY
        This prevents insert of non-sequential values and is in accordance with SQL standard

*/



CREATE SCHEMA IF NOT EXISTS cha;


CREATE TYPE cha.Gender AS ENUM('MALE', 'FEMALE', 'UNISEX', 'NONE');
CREATE TYPE cha.CharacterVersionKind AS ENUM('DEAD', 'MAIN', 'PAST', 'PARTIAL');
/*
TODO
Enuma uzywać do podawania "najwyższej" rangą CharacterVersion, jaka jest znana danego Character.
--> jeśli postać zna DEAD to wie że umarł; jesli zna max MAIN to nie wie jeśli umarł, a dalej...
Zastanowić się jeszcze nad znaczeniem relacji PAST do PARTIAL i nad ich kolejnością.
*/
-- ==========================================


CREATE TABLE cha.FirstNameGroup (
  id INT GENERATED BY DEFAULT AS IDENTITY,
  title VARCHAR(100) NOT NULL,  -- affix ex. *-os/*-as
  description VARCHAR(10000),
  -- ---------------------
  CONSTRAINT cha_firstnamegroup_pk       PRIMARY KEY (id),
  CONSTRAINT cha_firstnamegroup_title_uq UNIQUE (title)
);


CREATE TABLE cha.FirstName (
  id INT GENERATED BY DEFAULT AS IDENTITY,
	firstnamegroupid INT NOT NULL,
  gender cha.Gender NOT NULL DEFAULT 'MALE',
  originid INT,   -- if firstname comes from another firstname
	nominative VARCHAR(50) NOT NULL,
	genitive VARCHAR(50),
	description VARCHAR(10000),
  -- ---------------------
  CONSTRAINT cha_firstname_pk                PRIMARY KEY (id),
  CONSTRAINT cha_firstname_firstnamegroup_fk FOREIGN KEY (firstnamegroupid) REFERENCES cha.FirstNameGroup(id) ON DELETE NO ACTION,
  CONSTRAINT cha_firstname_origin_fk         FOREIGN KEY (originid) REFERENCES cha.FirstName(id) ON DELETE NO ACTION,
  CONSTRAINT cha_firstname_nominative_uq     UNIQUE (nominative)
);
CREATE INDEX cha_firstname_firstnamegroupid_ix ON cha.FirstName USING btree (firstnamegroupid);
CREATE INDEX cha_firstname_originid_ix         ON cha.FirstName USING btree (originid);


-- Gracz ma dostęp do Tagów których jest autorem + gdzie authorid NULL (=defaultowe)
CREATE TABLE cha.FirstNameTag (
  id INT GENERATED BY DEFAULT AS IDENTITY,
  authorid INT,
  title VARCHAR(50) NOT NULL,
  color VARCHAR(50) NOT NULL DEFAULT '#000000',
  -- ---------------------
  CONSTRAINT cha_firstnametag_pk       PRIMARY KEY (id),
  CONSTRAINT cha_firstnametag_user_fk  FOREIGN KEY (authorid) REFERENCES public.Users_User(id) ON DELETE CASCADE
);
CREATE INDEX cha_firstnametag_authorid_ix ON cha.FirstNameTag USING btree (authorid);


CREATE TABLE FirstNameM2MFirstNameTag (
  id INT GENERATED BY DEFAULT AS IDENTITY,
  firstnameid INT NOT NULL,
  firstnametagid INT NOT NULL,
  -- ---------------------
  CONSTRAINT cha_FirstNameM2MFirstNameTag_pk PRIMARY KEY (id)
);


-- ==========================================


CREATE TABLE cha.FamilyNameGroup (
  id INT GENERATED BY DEFAULT AS IDENTITY,
  title VARCHAR(100) NOT NULL,
  description VARCHAR(10000),
  -- ---------------------
  CONSTRAINT cha_familynamegroup_pk        PRIMARY KEY (id),
  CONSTRAINT cha_familynamegroup_title_uq  UNIQUE (title)
);


CREATE TABLE cha.FamilyName (
  id INT GENERATED BY DEFAULT AS IDENTITY,
	familynamegroupid INT NOT NULL,
  originid INT,
	nominative VARCHAR(50) NOT NULL,
	nominative_pl VARCHAR(50) NOT NULL,
	genitive VARCHAR(50),
	genitive_pl VARCHAR(50),
	description VARCHAR(10000),
  -- ---------------------
  CONSTRAINT cha_familyname_pk                 PRIMARY KEY (id),
  CONSTRAINT cha_familyname_familynamegroup_fk FOREIGN KEY (familynamegroupid) REFERENCES cha.FamilyNameGroup(id) ON DELETE NO ACTION,
  CONSTRAINT cha_familyname_origin_fk          FOREIGN KEY (originid) REFERENCES cha.FamilyName(id) ON DELETE NO ACTION,
  CONSTRAINT cha_familyname_nominative_uq      UNIQUE (nominative)
);
CREATE INDEX cha_familyname_familynamegroupid_ix ON cha.FamilyName USING btree (familynamegroupid);
CREATE INDEX cha_familyname_originid_ix          ON cha.FamilyName USING btree (originid);


-- Gracz ma dostęp do Tagów których jest autorem + gdzie authorid NULL (=defaultowe)
CREATE TABLE cha.FamilyNameTag (
  id INT GENERATED BY DEFAULT AS IDENTITY,
  authorid INT,
  title VARCHAR(50) NOT NULL,
  color VARCHAR(50) NOT NULL DEFAULT '#000000',
  -- ---------------------
  CONSTRAINT cha_familynametag_pk       PRIMARY KEY (id),
  CONSTRAINT cha_familynametag_user_fk  FOREIGN KEY (authorid) REFERENCES public.Users_User(id) ON DELETE CASCADE
);
CREATE INDEX cha_familynametag_authorid_ix ON cha.FamilyNameTag USING btree (authorid);


CREATE TABLE cha.FamilyNameM2MFamilyNameTag (
  id INT GENERATED BY DEFAULT AS IDENTITY,
  familynameid INT NOT NULL,
  familynametagid INT NOT NULL,
  -- ---------------------
  CONSTRAINT cha_FamilyNameM2MFamilyNameTag_pk PRIMARY KEY (id)
);


-- ==========================================

CREATE OR REPLACE FUNCTION cha.get_characterversion_fullname(
	firstnameid INT,
	familynameid INT,
	nickname TEXT,
	originname TEXT
) RETURNS TEXT AS $$
DECLARE
	firstname TEXT;
	familyname TEXT;
BEGIN
	IF firstname IS NOT NULL THEN
		firstname = (SELECT nominative FROM cha.FirstName WHERE id = firstnameid);
	END IF;
  IF familyname IS NOT NULL THEN
		familyname = (SELECT nominative FROM cha.FamilyName WHERE id = familyname);
	END IF;
	RETURN COALESCE(firstname, '') || COALESCE(familyname, '') || COALESCE(nickname, '') || COALESCE(originname, '');
END
$$ LANGUAGE plpgsql IMMUTABLE;


CREATE TABLE cha.Character (
  id INT GENERATED BY DEFAULT AS IDENTITY,
  userid INT NOT NULL,
  _maincharacterversion VARCHAR(100) NOT NULL,
  _createdat TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  -- ---------------------
  CONSTRAINT cha_character_pk                       PRIMARY KEY (id),
  CONSTRAINT cha_character_user_fk                  FOREIGN KEY (userid) REFERENCES public.Users_User(id) ON DELETE NO ACTION,
  CONSTRAINT cha_character_maincharacterversion_uq  UNIQUE (_maincharacterversion)
);
CREATE INDEX cha_character_userid_ix  ON cha.Character USING btree (userid);


CREATE TABLE cha.CharacterVersion (
  id INT GENERATED BY DEFAULT AS IDENTITY,
  characterid INT NOT NULL,
  pictureid INT NOT NULL,
  versionkind cha.CharacterVersionKind NOT NULL DEFAULT 'MAIN',
  isalive BOOLEAN NOT NULL DEFAULT TRUE,
  isalterego BOOLEAN NOT NULL DEFAULT FALSE,
  firstnameid INT,
  familynameid INT,
  nickname VARCHAR(50),
  originname VARCHAR(50),
  fullname VARCHAR(100)
    GENERATED ALWAYS AS (cha.get_characterversion_fullname(firstnameid, familynameid, nickname, originname)) STORED,
    -- Django unmanaged: fullname = CharField()
    -- Django unmanaged: __str__ = fullname [DEAD]
  description VARCHAR(10000),
  strength INT,
  dexterity INT,
  endurance INT,
  power INT,
  experience INT,
  _createdat TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  -- ---------------------
  CONSTRAINT cha_characterversion_pk            PRIMARY KEY (id),
  CONSTRAINT cha_characterversion_character_fk  FOREIGN KEY (characterid) REFERENCES cha.Character(id) ON DELETE NO ACTION,
  CONSTRAINT cha_characterversion_picture_fk    FOREIGN KEY (pictureid) REFERENCES res.Picture(id) ON DELETE NO ACTION,
  CONSTRAINT cha_characterversion_firstname_fk  FOREIGN KEY (firstnameid) REFERENCES cha.FirstName(id) ON DELETE NO ACTION,
  CONSTRAINT cha_characterversion_familyname_fk FOREIGN KEY (familynameid) REFERENCES cha.FamilyName(id) ON DELETE NO ACTION,
  CONSTRAINT cha_characterversion_strength_chk  CHECK (strength IS NULL OR (strength >= 1 AND strength <= 20)),
  CONSTRAINT cha_characterversion_dexterity_chk CHECK (dexterity IS NULL OR (dexterity >= 1 AND dexterity <= 20)),
  CONSTRAINT cha_characterversion_endurance_chk CHECK (endurance IS NULL OR (endurance >= 1 AND endurance <= 20)),
  CONSTRAINT cha_characterversion_power_chk     CHECK (experience IS NULL OR (experience >= 1 AND experience <= 20))
);
CREATE INDEX cha_characterversion_characterid_ix  ON cha.CharacterVersion USING btree (characterid);
CREATE INDEX cha_characterversion_firstnameid_ix  ON cha.CharacterVersion USING btree (firstnameid);
CREATE INDEX cha_characterversion_familynameid_ix ON cha.CharacterVersion USING btree (familynameid);



CREATE OR REPLACE FUNCTION cha.set_character_maincharacterversion()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE cha.Character
    SET _maincharacterversion = NEW.fullname
    WHERE id = NEW.characterid;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER characterversion_insert_tr
	AFTER INSERT ON cha.CharacterVersion
	FOR EACH ROW
	WHEN (NEW.versionkind = 'MAIN')
	EXECUTE FUNCTION cha.set_character_maincharacterversion();


/*
Aktualne rozwiązanie: Character a CharacterVersion

Character
---------
To "głębsza" platforma dla relacji kanonicznych, czyli dotyczących danej jednostki:
  - to Character zna cudze CharacterVersion, on też zna różne LocationVersion

CharacterVersion
----------------
To płytsza platforma, "fenotyp", to co się jawi otoczeniu, dla relacji względnych:
  - to jako CharacterVersion dana postać jest znana innym Character, występuje w różnych Location itd.

*/


/*

TODO 1: NPC isalive False
Zrobić mechanizm, częściowo administracyjny - formularze itp. - oznaczania NPCów jako umarłych.
Musi się wtedy tworzyć nowa wersja z __str__ = FULLNAME [DEAD] i to ją dodaję do wydarzenia, w ten sposób dając wszystkim uczestnikom nową, martwą wersję.

*/

-- TODO 3: jak już będzie Toponomikon: FirstNameToLocationLink, FamilyNameToLocationLink:
--    dzięki nim wyświetlanie po lokacjach i możliwość randomowego generowania FirstName+LastName, FirstName+[OriginName based on Location] ex. Aos z Keii

CREATE TABLE cha.CharacterVersionTag (
  id INT GENERATED BY DEFAULT AS IDENTITY,
  authorid INT,
  title VARCHAR(50) NOT NULL,
  color VARCHAR(50) NOT NULL DEFAULT '#000000',
  -- ---------------------
  CONSTRAINT cha_characterversiontag_pk       PRIMARY KEY (id),
  CONSTRAINT cha_characterversiontag_user_fk  FOREIGN KEY (authorid) REFERENCES public.Users_User(id) ON DELETE CASCADE
);
CREATE INDEX cha_characterversiontag_authorid_ix ON cha.CharacterVersionTag USING btree (authorid);



CREATE TABLE cha.CharacterVersionM2MCharacterVersionTag (
  id INT GENERATED BY DEFAULT AS IDENTITY,
  characterversionid INT NOT NULL,
  characterversiontagid INT NOT NULL,
  -- ---------------------
  CONSTRAINT cha_CharacterVersionM2MCharacterVersionTag_pk PRIMARY KEY (id)
);





CREATE TABLE cha.CharacterKnownCharacterVersionLink (
  id INT GENERATED BY DEFAULT AS IDENTITY,
  characterid INT NOT NULL,
  characterversionid INT NOT NULL,
  isdirect BOOLEAN NOT NULL DEFAULT TRUE,
  identifiedwith INT[],     -- array id CharacterVersion z kind "ALTEREGO", które zdaniem Character są identyczne z "tą" CharacterVersion
  -- ---------------------
  CONSTRAINT cha_characterknowncharacterversionlink_pk                  PRIMARY KEY (id),
  CONSTRAINT cha_characterknowncharacterversionlink_character_fk        FOREIGN KEY (characterid) REFERENCES cha.Character(id) ON DELETE CASCADE,
  CONSTRAINT cha_characterknowncharacterversionlink_characterversion_fk FOREIGN KEY (characterversionid) REFERENCES cha.CharacterVersion(id) ON DELETE CASCADE
);
CREATE INDEX cha_characterknowncharacterversionlink_characterid_ix        ON cha.CharacterKnownCharacterVersionLink USING btree (characterid);
CREATE INDEX cha_characterknowncharacterversionlink_characterversionid_ix ON cha.CharacterKnownCharacterVersionLink USING btree (characterversionid);


